using(Distributed)

Threads.nthreads()
addprocs(3)

@everywhere using(Distributions)
@everywhere using(DataFrames)
@everywhere using(JLD2)

#Load code
@everywhere cd("cpr\\code\\abm")
@everywhere include("cpr_setup.jl")
@everywhere include("cpr_lim.jl")


S =expand_grid( [900],               #Population Size
                [6],                #ngroups
                [[3, 2]],           #lattice, will be replaced below
                [1, 1500],          #Variance
                [0,1],              #Degradability
                [.5, 1],            #Defensibility
                [false],            #Experiment_leak
                [false],            #experiment_punish
                [1],                #experiment_group
                [false],            #cmls
                [true],             #social learning
                [false, true],       #leakage
                [false, true]       #self policing
                )



#set up a smaller call function that allows for only a sub-set of pars to be manipulated
@everywhere function g(n, ng, l, v, dg, df, el, ep, eg, c, sl, lk, sp)
    cpr_abm(n = n,
            nrounds = 2000,
            nsim = 30,
            ngroups = ng,
            lattice = l,
            var_forest = v,
            degradability = dg,
            defensibility = df,
            experiment_leak = el,
            experiment_punish = ep,
            experiment_group = eg,
            cmls = c,
            social_learning = sl,
            leak = lk,
            self_policing = sp )
end

#Verify
check = false

if check == true
    for i = 1:128
        println(i)
        abm_dat = g(S[i,1], S[i,2], S[i,3], S[i,4], S[i,5], S[i,6], S[i,7], S[i,8], S[i,9], S[i,10])
    end
end
abm_dat = pmap(g, S[:,1], S[:,2], S[:,3], S[:,4], S[:,5], S[:,6], S[:,7], S[:,8], S[:,9], S[:,10] , S[:,11], S[:,12], S[:,13])
